Context

Project uses Supabase for auth + Postgres and a web frontend (Next.js / React). The project ID is kmafzzvdleprqhkeztsp.
Current issue: frontend repeatedly fails requests to /rest/v1/users (503). The admin dashboard shows "Error fetching admin stats". There are additional runtime/build issues (Edge runtime and dynamic/cookie routes, missing client-only hooks).
Goal: restore stable profile/user linking, stop the 503 storm, fix admin dashboard and remaining site errors, and add protections (retry/backoff, caching, rate limits).
High-level deliverables

Fix profile â†” user linking so frontend shows correct profile data for authenticated users.
Stop repeated failing requests and fix admin dashboard (short-term mitigation + long-term improvements).
Fix build/runtime issues (Edge imports, dynamic routes, client-only hooks).
Add safety & performance improvements: debouncing/deduping, retry with backoff, server-side caching for heavy admin queries, and basic rate-limiting.
Provide tests and verification steps and a brief rollback plan.
Exact tasks (apply in this order) A. Immediate mitigation (reduce load & stop 503 loop)

Add env flag NEXT_PUBLIC_DISABLE_ADMIN_STATS (default false). If true, admin pages must not auto-fetch admin stats.
Add server-side in-memory cache for admin stats endpoint (ttl 60s).
Add retry cap (max 3) + exponential backoff and debounce to the client fetch for admin stats and any repeated user list calls.
Short-circuit client fetch when NEXT_PUBLIC_DISABLE_ADMIN_STATS === 'true'.
B. Fix profile / user linking

Search repo for occurrences of supabase.from('users') and REST GET to /rest/v1/users.
Ensure authenticated requests pass Authorization: Bearer <access_token> to Supabase client (or use supabase.auth.getUser()).
Change frontend profile fetch to use the supabase client instance (supabase.auth.getUser() or supabase.from('profiles').select(...).eq('id', user.id)) instead of REST if it's not already.
Ensure users table vs profiles table mapping is correct:
Confirm auth.uid() values exist in profiles.user_id (or profiles.auth_user_id). If mismatch, create migration or mapping function to copy/align IDs.
Add a server API route (e.g., /api/me/profile) that:
Validates the incoming Supabase JWT (use Supabase client or JWKS).
Queries the profiles table (not raw users in REST) using service role key if needed.
Returns normalized profile object to front-end.
Update frontend to call /api/me/profile (or use supabase client with correct auth) and remove direct mass-requests to /rest/v1/users.
C. Fix admin dashboard root causes

Find and fix loops that repeatedly call /rest/v1/users. Typical fixes:
Replace many direct client calls with a single consolidated admin API route that performs aggregated queries server-side and caches results.
Debounce frontend hooks so they don't re-run on each render.
Limit retries and add exponential backoff.
Add server-side caching and optionally rate-limiting to admin endpoints.
D. Build/runtime fixes

For each API route flagged by runtime errors (e.g., app/api/me/balance and app/api/meet-greet/check-room):
Add at top: export const dynamic = 'force-dynamic';
Remove or relocate any Node-only imports from Edge-bound routes; use Deno or Web APIs where required.
Fix client-only React components used in server components by adding "use client" at top of those components or moving them to client-side bundles.
Fix missing or undefined hooks (e.g., useToast): find where they are used and either import or replace with safe fallback.
E. Safety & hardening

Add fetchWithRetry utility with capped retries and exponential backoff; wrap all external fetches to Supabase REST with it.
Add simple server-side rate-limiter (e.g., per-IP in-memory sliding window) for public endpoints used by admin UI.
Add server caching (in-memory with TTL) for heavy admin queries; optionally use Redis if available.
Add logging + Sentry/console warnings for repeated 5xx responses to trigger action.
F. Tests, verification, and rollout

Unit / integration tests:
Test /api/me/profile returns correct profile when given valid access token.
Test admin stats endpoint returns cached results and that successive calls within TTL do not hit DB.
Manual smoke tests:
Log in as a normal user -> visit profile page -> verify fields load within 1 request.
Log in as admin -> visit admin dashboard -> verify it loads once, no repeated 503s, metrics show cached behavior.
Run a stress test with 50 concurrent admin dashboard open requests and confirm rate-limiter/caching prevents DB overload.
Build & deploy:
Run local build (pnpm/npm/yarn build).
Run curl requests to key routes to validate responses.
Rollback plan:
Revert env var to re-enable previous behavior.
Re-deploy previous commit if errors emerge.
Files to modify (search & patch)

Search commands to find offending code:
grep -R "supabase.from('users'" -n
grep -R "/rest/v1/users" -n
grep -R "useAdminStats" -n
grep -R "app/api/me/balance" -n
grep -R "app/api/meet-greet/check-room" -n
Patches to prepare:
lib/utils/fetchWithRetry.ts (retry + backoff)
lib/utils/debounce.ts (debounce)
env example (.env.example): NEXT_PUBLIC_DISABLE_ADMIN_STATS=false
client hook (e.g., hooks/useAdminStats.tsx): short-circuit + use fetchWithRetry + debounce
server admin route (e.g., app/api/admin/stats/route.ts): add caching + dynamic export
app/api/me/balance/route.ts and app/api/meet-greet/check-room/route.ts: add export const dynamic = 'force-dynamic';
api route /api/me/profile: validate token -> fetch profile -> return normalized data
README update: how to toggle NEXT_PUBLIC_DISABLE_ADMIN_STATS and steps to transition to Neon.
Example small snippets (guidance)

Short-circuit in client: if (process.env.NEXT_PUBLIC_DISABLE_ADMIN_STATS === 'true') return { data: null, loading: false };
fetchWithRetry skeleton:
async function fetchWithRetry(url, options, retries=3, backoff=500) { ... exponential backoff ... }
Server cache: const cache = new Map(); // store {value, expiresAt} if (cache has key && expiresAt > Date.now()) return cached value
Deliverable format

For each file changed, provide a unified diff patch the Replit Assistant can apply.
Provide the exact grep commands output (files + lines) so we know all places changed.
Provide test commands (curl examples) and expected responses.
Provide short rationale for each change.
Permissions & safety

I will not change destructive SQL or remove tables. If migrations are required to align profiles/users, prompt me first and I will provide migration SQL to review.
For any change using service_role keys or secrets, ensure they are stored in project secrets, not committed to repo.
Acceptance criteria

After applying patches and deploying:
Admin dashboard no longer triggers repeated 503s; calls are cached and debounced.
Profile page loads profile data reliably using validated JWT.
Build no longer throws Edge/runtime related errors for the listed API routes.
System logs show no repeated 5xx storms and retry/backoff prevents floods.
If you want, I can now:

Produce the actual unified diffs for the files listed above (TypeScript by default).
Or produce a runnable checklist you can give to a developer to implement changes manually.