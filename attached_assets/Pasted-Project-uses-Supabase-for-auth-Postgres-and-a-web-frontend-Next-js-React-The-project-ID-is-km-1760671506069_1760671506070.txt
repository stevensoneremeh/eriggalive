Project uses Supabase for auth + Postgres and a web frontend (Next.js / React). The project ID is kmafzzvdleprqhkeztsp.
Current issue: frontend repeatedly fails requests to /rest/v1/users (503). The admin dashboard shows "Error fetching admin stats". There are additional runtime/build issues (Edge runtime and dynamic/cookie routes, missing client-only hooks).
Goal: restore stable profile/user linking, stop the 503 storm, fix admin dashboard and remaining site errors, and add protections (retry/backoff, caching, rate limits).
High-level deliverables

Fix profile ↔ user linking so frontend shows correct profile data for authenticated users.
Stop repeated failing requests and fix admin dashboard (short-term mitigation + long-term improvements).
Fix build/runtime issues (Edge imports, dynamic routes, client-only hooks).
Add safety & performance improvements: debouncing/deduping, retry with backoff, server-side caching for heavy admin queries, and basic rate-limiting.
Provide tests and verification steps and a brief rollback plan.
Exact tasks (apply in this order) A. Immediate mitigation (reduce load & stop 503 loop)

Add env flag NEXT_PUBLIC_DISABLE_ADMIN_STATS (default false). If true, admin pages must not auto-fetch admin stats.
Add server-side in-memory cache for admin stats endpoint (ttl 60s).
Add retry cap (max 3) + exponential backoff and debounce to the client fetch for admin stats and any repeated user list calls.
Short-circuit client fetch when NEXT_PUBLIC_DISABLE_ADMIN_STATS === 'true'.
B. Fix profile / user linking

Search repo for occurrences of supabase.from('users') and REST GET to /rest/v1/users.
Ensure authenticated requests pass Authorization: Bearer <access_token> to Supabase client (or use supabase.auth.getUser()).
Change frontend profile fetch to use the supabase client instance (supabase.auth.getUser() or supabase.from('profiles').select(...).eq('id', user.id)) instead of REST if it's not already.
Ensure users table vs profiles table mapping is correct:
Confirm auth.uid() values exist in profiles.user_id (or profiles.auth_user_id). If mismatch, create migration or mapping function to copy/align IDs.
Add a server API route (e.g., /api/me/profile) that:
Validates the incoming Supabase JWT (use Supabase client or JWKS).
Queries the profiles table (not raw users in REST) using service role key if needed.
Returns normalized profile object to front-end.
Update frontend to call /api/me/profile (or use supabase client with correct auth) and remove direct mass-requests to /rest/v1/users.
C. Fix admin dashboard root causes

Find and fix loops that repeatedly call /rest/v1/users. Typical fixes:
Replace many direct client calls with a single consolidated admin API route that performs aggregated queries server-side and caches results.
Debounce frontend hooks so they don't re-run on each render.
Limit retries and add exponential backoff.
Add server-side caching and optionally rate-limiting to admin endpoints.
D. Build/runtime fixes

For each API route flagged by runtime errors (e.g., app/api/me/balance and app/api/meet-greet/check-room):
Add at top: export const dynamic = 'force-dynamic';
Remove or relocate any Node-only imports from Edge-bound routes; use Deno or Web APIs where required.
Fix client-only React components used in server components by adding "use client" at top of those components or moving them to client-side bundles.
Fix missing or undefined hooks (e.g., useToast): find where they are used and either import or replace with safe fallback.
E. Safety & hardening

Add fetchWithRetry utility with capped retries and exponential backoff; wrap all external fetches to Supabase REST with it.
Add simple server-side rate-limiter (e.g., per-IP in-memory sliding window) for public endpoints used by admin UI.
Add server caching (in-memory with TTL) for heavy admin queries; optionally use Redis if available.
Add logging + Sentry/console warnings for repeated 5xx responses to trigger action.
F. Tests, verification, and rollout

Unit / integration tests:
Test /api/me/profile returns correct profile when given valid access token.
Test admin stats endpoint returns cached results and that successive calls within TTL do not hit DB.
Manual smoke tests:
Log in as a normal user -> visit profile page -> verify fields load within 1 request.
Log in as admin -> visit admin dashboard -> verify it loads once, no repeated 503s, metrics show cached behavior.
Run a stress test with 50 concurrent admin dashboard open requests and confirm rate-limiter/caching prevents DB overload.
Build & deploy:
Run local build (pnpm/npm/yarn build).
Run curl requests to key routes to validate responses.
Rollback plan:
Revert env var to re-enable previous behavior.
Re-deploy previous commit if errors emerge.
Files to modify (search & patch)

Search commands to find offending code:
grep -R "supabase.from('users'" -n
grep -R "/rest/v1/users" -n
grep -R "useAdminStats" -n
grep -R "app/api/me/balance" -n
grep -R "app/api/meet-greet/check-room" -n
Patches to prepare:
lib/utils/fetchWithRetry.ts (retry + backoff)
lib/utils/debounce.ts (debounce)
env example (.env.example): NEXT_PUBLIC_DISABLE_ADMIN_STATS=false
client hook (e.g., hooks/useAdminStats.tsx): short-circuit + use fetchWithRetry + debounce
server admin route (e.g., app/api/admin/stats/route.ts): add caching + dynamic export
app/api/me/balance/route.ts and app/api/meet-greet/check-room/route.ts: add export const dynamic = 'force-dynamic';
api route /api/me/profile: validate token -> fetch profile -> return normalized data
README update: how to toggle NEXT_PUBLIC_DISABLE_ADMIN_STATS and steps to transition to Neon.
Example small snippets (guidance)

Short-circuit in client: if (process.env.NEXT_PUBLIC_DISABLE_ADMIN_STATS === 'true') return { data: null, loading: false };
fetchWithRetry skeleton:
async function fetchWithRetry(url, options, retries=3, backoff=500) { ... exponential backoff ... }
Server cache: const cache = new Map(); // store {value, expiresAt} if (cache has key && expiresAt > Date.now()) return cached value
Deliverable format

For each file changed, provide a unified diff patch the Replit Assistant can apply.
Provide the exact grep commands output (files + lines) so we know all places changed.
Provide test commands (curl examples) and expected responses.
Provide short rationale for each change.
Permissions & safety

I will not change destructive SQL or remove tables. If migrations are required to align profiles/users, prompt me first and I will provide migration SQL to review.
For any change using service_role keys or secrets, ensure they are stored in project secrets, not committed to repo.
Acceptance criteria

After applying patches and deploying:
Admin dashboard no longer triggers repeated 503s; calls are cached and debounced.
Profile page loads profile data reliably using validated JWT.
Build no longer throws Edge/runtime related errors for the listed API routes.
System logs show no repeated 5xx storms and retry/backoff prevents floods.
If you want, I can now:

Produce the actual unified diffs for the files listed above (TypeScript by default).
Or produce a runnable checklist you can give to a developer to implement changes manually.
Which would you like next: full diffs (TS), or a step-by-step checklist to hand to your developer?

Give me all in a single prompt for replit assistant to do this perfectly




Reasoned
Below is a single, complete prompt you can paste into Replit Assistant (or any capable AI/developer) to implement the full fixset: stop the 503 storm, fix profile ↔ user linking, harden admin dashboard, and resolve runtime/build issues. It includes context, exact tasks (ordered), precise search commands, ready-to-apply patches to produce, code snippets to use, tests, and rollback instructions. Ask the assistant to return unified diffs for each file changed and a runbook of verification steps.

Paste this whole prompt into Replit Assistant:

Project context

Repo uses Supabase (Auth + Postgres) and a Next.js/React frontend. Project id: kmafzzvdleprqhkeztsp.
Primary problems:
Repeated failing requests to Supabase users REST endpoint (/rest/v1/users) causing 503 storms.
Profile page not reliably showing the user's profile (mismatch or missing mapping between Auth users and profile rows).
Admin dashboard shows "Error fetching admin stats" and triggers repeated requests.
Build/runtime errors from API routes that use cookies or Node-only imports in Edge runtime (e.g., app/api/me/balance and app/api/meet-greet/check-room).
Missing or misused client-only components/hooks in server components.
Goals:
Fix profile ↔ user linking so authenticated users see correct profile data.
Stop the 503 loop and stabilize admin dashboard (short-term mitigation + long-term fixes).
Fix build/runtime issues and ensure routes that require Node or cookies are dynamic.
Add safety: retry/backoff, debounce, dedupe, caching, and basic rate-limiting.
Provide tests, verification, and rollback plan.
Preferred language for any new utility files: TypeScript.

Top-level tasks (execute in this order)

Repo search (list all matches first)
Run these commands and paste the output (file:line context):
grep -R "supabase.from('users')" -n || true
grep -R "/rest/v1/users" -n || true
grep -R "useAdminStats" -n || true
grep -R "app/api/me/balance" -n || true
grep -R "app/api/meet-greet/check-room" -n || true
grep -R "useToast" -n || true
grep -R "use client" -n || true
rg "supabase.from\(|/rest/v1/users" || true
Return a concise list of files referencing Supabase users and all API routes under app/api that look relevant.
Add environment flag and .env example
Add .env.example entry: NEXT_PUBLIC_DISABLE_ADMIN_STATS=false
Ensure docs/README notes how to set NEXT_PUBLIC_DISABLE_ADMIN_STATS=true to short-circuit admin stats during incident.
Add utilities (TypeScript)
Add lib/utils/fetchWithRetry.ts
Exports async function fetchWithRetry(input: RequestInfo, init?: RequestInit, { retries = 3, backoffMs = 300 } = {}): Response
Implements exponential backoff (backoffMs * 2^(attempt -1)), jitter, and throws on final failure.
Validates only idempotent-safe retries for GET/HEAD by default; for others require explicit forceRetry flag.
Add lib/utils/debounce.ts
Exports function debounce<T extends (...args: any[]) => any>(fn: T, waitMs = 300): T
Add lib/utils/dedupe.ts (optional but recommended)
Simple request deduper (keyed by URL + body) so simultaneous identical calls return same promise.*
Client-side changes: admin fetch and user/profile fetching
Locate any client code calling supabase.from('users') or /rest/v1/users. For each occurrence:

Replace direct REST list calls with either:
A server API route (see next) for admin reads (preferred), OR
Use the standard supabase client properly initialized with auth context (supabase.auth.getUser() or supabase.auth.getSession()) and call supabase.from('profiles') or supabase.from('users') as appropriate.
Wrap frontend fetches with fetchWithRetry and debounce. Short-circuit when NEXT_PUBLIC_DISABLE_ADMIN_STATS === 'true'.
Use dedupe to avoid duplicate parallel requests.
If you have a hook like hooks/useAdminStats.ts(x), modify it so:

If process.env.NEXT_PUBLIC_DISABLE_ADMIN_STATS === 'true' return { data: null, loading: false, error: null } and do not fetch.
Otherwise, call a server API route /api/admin/stats (see next).
Ensure hook uses useEffect with proper dependency array and a debounce to avoid re-triggering on render.
Add server API endpoints (Next.js app/api) A. /api/me/profile (server-safe)
Purpose: canonical endpoint to return the current user's profile, validating the incoming Supabase access token and returning normalized profile fields.
Implementation requirements:
Validate Authorization: Bearer <access_token> header from client (or read cookies if using cookie session).
Use Supabase client instantiated with SUPABASE_SERVICE_ROLE_KEY only on server, or verify JWT via Supabase public keys; prefer server client to query profiles safely.
Query the profiles table (not raw auth.users) for the matching user id. If your profiles table uses a different foreign key name (e.g., auth_user_id), detect that and query accordingly.
Return consistent profile shape: { id, email?, full_name?, avatar_url?, role?, created_at?, ... }.
Do not return service_role_key or sensitive fields.
Rate-limit moderately (e.g., 10 req/min per IP) and log suspicious usage.
Add export const dynamic = 'force-dynamic'; at top of route file.
B. /api/admin/stats

Purpose: single server-side aggregated endpoint for admin dashboard metrics (counts, recent errors, user counts).
Implementation requirements:
Require Authorization: Bearer <access_token> that maps to an admin claim in JWT (e.g., auth.jwt() ->> 'role' = 'admin') OR require cookie auth and check session.
Use SUPABASE_SERVICE_ROLE_KEY on the server only to run the admin-level queries, or run queries with the admin user's role as validated from the JWT.
Implement in-memory cache: Map<string, { value: any, expiresAt: number }>.
Cache key: 'admin:stats'
TTL: 60 seconds
On cache hit return cached value; on miss query DB and set cache.
Add basic rate-limiting: per-IP sliding window (limit ~10 req/min).
Add retry/backoff only for DB transient errors, but avoid retry loops (max 2).
Add export const dynamic = 'force-dynamic'; at top of route file.
C. Update any existing API routes that call Supabase or access cookies

For routes that previously errored in Edge runtime (e.g., app/api/me/balance, app/api/meet-greet/check-room):
Add at top: export const dynamic = 'force-dynamic';
Remove/replace Node-only imports; use Web/Deno APIs for Edge where possible.
If cookies or Node libs are required and cannot be converted, mark dynamic and use Node-style imports.
Fix profile/user mapping and possible DB migration
Search for tables: profiles, users, auth.users differences:
Execute (developer/local): SELECT table_name FROM information_schema.tables WHERE table_name IN ('profiles','users') OR table_schema='auth';
Confirm the profiles table has a user id column matching auth.uid() (UUID string). If mismatch:
Prepare a non-destructive mapping SQL migration (review first) to align keys:
Example to detect mismatches: SELECT p.* FROM profiles p LEFT JOIN auth.users u ON p.user_id::text = u.id::text WHERE u.id IS NULL LIMIT 10;
Example migration (only after review): insert missing profiles or copy fields from auth.users into profiles, but do NOT run without confirmation.
Ensure frontend uses profiles table (or canonical table) to render profile pages, not the auth.users REST endpoint.*
Debounce/dedupe and retry application-wide
Wrap all external fetches to Supabase REST with fetchWithRetry and dedupe.
Ensure retry only on idempotent GETs or when caller explicitly asks.
Add sensible caps: retries <= 3, initial backoff 300ms.
Admin dashboard fixes
Replace any frontend code that iterates through users via supabase.from('users') directly with:
Call to /api/admin/stats for aggregated metrics, and
A server-side paginated endpoint for listing users in pages (e.g., /api/admin/users?page=1&limit=50) which enforces rate-limit and caching.
Ensure heavy queries have proper indexes on columns used in WHERE clauses.
Build/runtime fixes (Next.js)
Add "use client" at top of any React components used only on client side and ensure they live in a client-only folder if needed.
For any Edge functions or server components, ensure imports are Edge-compatible or mark the route dynamic.
Replace direct usage of process.env in client-side bundles with NEXT_PUBLIC_ prefixed env vars only._
Logging, observability, and alerting
Add console warnings for repeated 5xx responses and increment a simple in-memory counter; if repeated across 20s window escalate to logs/alerts.
If Sentry configured, add an optional SENTRY_DSN env var usage to report errors.
Tests & verification
Unit tests:
test that fetchWithRetry retries and respects backoff.
test /api/me/profile returns 401 for missing token, 200 for valid token and correct profile shape.
test /api/admin/stats returns cached result within TTL and hits DB on expiry.
Manual smoke tests (curl commands to run locally):
Login as user, capture access token -> curl -H "Authorization: Bearer " http://localhost:3000/api/me/profile -> expect 200 and profile JSON.
As admin -> curl -H "Authorization: Bearer <admin_token>" http://localhost:3000/api/admin/stats -> expect 200; call again within 60s and ensure latency is significantly lower (cache hit).
Simulate repeated client page loads to ensure no repeated 503s.
Rollback plan
How to rollback quickly:
If issues appear after deploy, set NEXT_PUBLIC_DISABLE_ADMIN_STATS=true immediately and redeploy (short-circuits admin fetch).
Revert to previous commit on Git and redeploy.
If DB mapping migration required and causes issues, revert migration or restore DB snapshot.
Exact code snippets to use (copy/paste into diffs)

A) lib/utils/fetchWithRetry.ts

Use this exact logic:
Exponential backoff with jitter, maxRetries default 3, respect idempotent-only for automatic retries.
Return Response for successful fetch or throw last error.
B) Example /api/me/profile route (TypeScript, Next.js)

Validate Authorization header.
Instantiate server Supabase client with SUPABASE_SERVICE_ROLE_KEY (server-only).
Query profiles by id using the token-subject id.
Add export const dynamic = 'force-dynamic';
Return JSON with sanitized profile.
C) Example /api/admin/stats route

Use server Supabase service role.
Implement in-memory cache Map.
Add simple per-IP rate limiter.
Add export const dynamic = 'force-dynamic';
(If you want, I will provide exact full file contents as unified diffs for each file after you confirm where the project stores API routes, hooks, and utilities. But the assistant must return diffs for every file modified.)

Deliverable format requested from Replit Assistant

For each file changed, return a unified diff (git-style) that can be applied with git apply.
For each added file, include file path and content.
For each removed file, explain why.
After applying patches locally, run these commands and paste the outputs:
pnpm install (or npm/yarn)
pnpm build
pnpm dev (or start preview) for smoke testing
The curl verification commands listed above (with placeholder tokens)
Provide a short list of remaining manual steps (if any), and any places where the assistant requires secrets/env vars to be set.
Safety & constraints (do not perform destructive actions)

Do NOT run destructive SQL migrations without explicit confirmation and a DB backup snapshot.
Any migration SQL (in migrations/) must be provided for review before execution.
Do not commit service role keys to repo; use secrets.
Acceptance criteria (what "done" looks like)

Profile page shows correct current user's profile in one request.
Admin dashboard no longer triggers repeated 503s; requests are cached and debounced.
No Edge/runtime cookie errors from app/api/me/balance and app/api/meet-greet/check-room (routes marked dynamic if needed).
All new code is TypeScript (unless inconsistent with repo) and includes unit tests for utilities.
Clear rollback steps and test results included.
Optional: If you want the assistant to produce exact unified diffs now, add this confirmation:

"Please produce unified diffs for the files listed by the repo search output and include the path and content for new files."